// This file defines boilerplate code that forms part of every
// generated Go file.

package main

// header is included at the top of every generated Go file.
var header = `// This file was generated by gosp2go.

package main

import (
	gospAtomic "sync/atomic"
	gospFilePath "path/filepath"
	gospFlag "flag"
	gospFmt "fmt"
	gospJson "encoding/json"
	gospNet "net"
	gospOs "os"
	gospTime "time"
)

`

// trailer is included at the end of every generated Go file.
var trailer = `
type GospRequest struct {
	Hostname  string
	QueryArgs string
	PathInfo  string
	Uri       string
	UserAgent struct {
		Hostname string
		Port     int
		IP       string
	}
	ExitNow bool
}

func GospRequestFromFile(fn string) error {
	f, err := gospOs.Open(fn)
	if err != nil {
		return err
	}
	defer f.Close()
	dec := gospJson.NewDecoder(f)
	var gr GospRequest
	err = dec.Decode(&gr)
	if err != nil {
		return err
	}
	code := gospGenerateHTML(&gr)
	if code != 200 {
		return gospFmt.Errorf("HTTP status code %d", code)
	}
	return nil
}

func GospStartServer(fn string) error {
	dir, sock := gospFilePath.Split(fn)
	err := gospOs.Chdir(dir)
	if err != nil {
		return err
	}
	ln, err := gospNet.Listen("unix", sock)
	if err != nil {
		return err
	}
	var done int32
	for {
		conn, err := ln.Accept()
		if err != nil {
			return err
		}
		if gospAtomic.LoadInt32(&done) == 1 {
			return nil
		}
		go func(conn gospNet.Conn) {
			defer conn.Close()
			conn.SetDeadline(gospTime.Now().Add(10 * gospTime.Second))
			dec := gospJson.NewDecoder(conn)
			var gr GospRequest
			err = dec.Decode(&gr)
			if err != nil {
				return
			}
			if gr.ExitNow {
				gospAtomic.StoreInt32(&done, 1)
				c, err := gospNet.Dial("unix", sock)
				if err == nil {
					c.Close()
				}
				return
			}
			code := gospGenerateHTML(&gr)
			gospFmt.Fprintf(conn, "%d\n", code)
		}(conn)
	}
}

func main() {
	var err error
	sock := gospFlag.String("socket", "", "Unix socket (filename) on which to listen for JSON code")
	file := gospFlag.String("file", "", "File name from which to read JSON code")
	gospFlag.Parse()
	switch {
	case *file != "":
		err = GospRequestFromFile(*file)
	case *sock != "":
		err = GospStartServer(*sock)
	default:
		gospGenerateHTML(nil)
	}
	if err != nil {
		panic(err)
	}
	return
}
`
