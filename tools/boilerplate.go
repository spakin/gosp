// This file defines boilerplate code that forms part of every
// generated Go file.

package main

// header is included at the top of every generated Go file.
var header = `// This file was generated by gosp2go.

package main

import (
	gospJson "encoding/json"
	gospFlag "flag"
	gospFmt "fmt"
	gospIoutil "io/ioutil"
	gospNet "net"
	gospHttp "net/http"
	gospOs "os"
	gospFilePath "path/filepath"
	gospStrconv "strconv"
	gospAtomic "sync/atomic"
	gospTime "time"
)

`

var bodyBegin = `func GospGenerateHTML(gospReq *GospRequest, gospResp chan<- GospKeyValue) {
	gospMimeType := "text/html"
	gospHttpStatus := "200"
	defer func() {
		gospResp <- GospKeyValue{Key: "mime-type", Value: gospMimeType}
		gospResp <- GospKeyValue{Key: "http-status", Value: gospHttpStatus}
		close(gospResp)
	}()
	GospSetHttpStatus := func(s int) {
		gospHttpStatus = gospFmt.Sprintf("%d", s)
	}
	GospSetMimeType := func(mt string) {
		gospMimeType = mt
	}
	GospHeartbeat := func() {
		gospResp <- GospKeyValue{Key: "keep-alive", Value: ""}
	}
	_, _, _ = GospSetHttpStatus, GospSetMimeType, GospHeartbeat

`

// trailer is included at the end of every generated Go file.
var trailer = `
const gospTimeout = 5 * gospTime.Second

func GospLaunchHTMLGenerator(gospReq *GospRequest) (string, int, string) {
	r, w, err := gospOs.Pipe()
	if err != nil {
		return "text/html", gospHttp.StatusInternalServerError, ""
	}
	gospOut := gospOs.Stdout
	gospOs.Stdout = w
	defer func() {
		gospOs.Stdout = gospOut
	}()
	hCh := make(chan string, 1)
	go func() {
		html, err := gospIoutil.ReadAll(r)
		if err == nil {
			hCh <- string(html)
		} else {
			hCh <- ""
		}
		close(hCh)
	}()
	resp := make(chan GospKeyValue, 5)
	go func() {
		GospGenerateHTML(gospReq, resp)
		w.Close()
	}()
	mime := "text/html"
	http := gospHttp.StatusOK
	html := ""
	haveHtml := false
	haveMeta := false
	to := gospTime.NewTimer(gospTimeout)
AwaitCompletion:
	for !haveHtml || !haveMeta {
		select {
		case html = <-hCh:
			haveHtml = true
		case kv, ok := <-resp:
			if !ok {
				haveMeta = true
				continue AwaitCompletion
			}
			switch kv.Key {
			case "mime-type":
				mime = kv.Value
			case "http-status":
				http, err = gospStrconv.Atoi(kv.Value)
				if err != nil {
					http = gospHttp.StatusInternalServerError
				}
			case "keep-alive":
				if !to.Stop() {
					<-to.C
				}
				to.Reset(gospTimeout)
			}
		case <-to.C:
			http = gospHttp.StatusGatewayTimeout
			break AwaitCompletion
		}
	}
	if http != gospHttp.StatusOK {
		return mime, http, ""
	}
	return mime, http, html
}

type GospRequest struct {
	Hostname  string
	QueryArgs string
	PathInfo  string
	Uri       string
	UserAgent struct {
		Hostname string
		Port     int
		IP       string
	}
	ExitNow bool
}

type GospKeyValue struct {
	Key   string
	Value string
}

func GospRequestFromFile(fn string) error {
	f, err := gospOs.Open(fn)
	if err != nil {
		return err
	}
	defer f.Close()
	dec := gospJson.NewDecoder(f)
	var gr GospRequest
	err = dec.Decode(&gr)
	if err != nil {
		return err
	}
	_, code, html := GospLaunchHTMLGenerator(nil)
	if code != gospHttp.StatusInternalServerError {
		return gospFmt.Errorf("HTTP status code %d", code)
	}
	gospFmt.Print(html)
	return nil
}

func GospStartServer(fn string) error {
	dir, sock := gospFilePath.Split(fn)
	err := gospOs.Chdir(dir)
	if err != nil {
		return err
	}
	ln, err := gospNet.Listen("unix", sock)
	if err != nil {
		return err
	}
	var done int32
	for {
		conn, err := ln.Accept()
		if err != nil {
			return err
		}
		if gospAtomic.LoadInt32(&done) == 1 {
			return nil
		}
		go func(conn gospNet.Conn) {
			defer conn.Close()
			conn.SetDeadline(gospTime.Now().Add(10 * gospTime.Second))
			dec := gospJson.NewDecoder(conn)
			var gr GospRequest
			err = dec.Decode(&gr)
			if err != nil {
				return
			}
			if gr.ExitNow {
				gospAtomic.StoreInt32(&done, 1)
				c, err := gospNet.Dial("unix", sock)
				if err == nil {
					c.Close()
				}
				return
			}
			_, code, html := GospLaunchHTMLGenerator(&gr)
			gospFmt.Fprintf(conn, "%d\n\n", code)
			gospFmt.Fprint(conn, html)
		}(conn)
	}
}

func main() {
	var err error
	gospOs.Stdin = nil
	sock := gospFlag.String("socket", "", "Unix socket (filename) on which to listen for JSON code")
	file := gospFlag.String("file", "", "File name from which to read JSON code")
	gospFlag.Parse()
	switch {
	case *file != "":
		err = GospRequestFromFile(*file)
	case *sock != "":
		err = GospStartServer(*sock)
	default:
		_, code, html := GospLaunchHTMLGenerator(nil)
		if code != gospHttp.StatusOK {
			gospFmt.Fprintf(gospOs.Stderr, "HTTP status code %d\n", code)
		} else {
			gospFmt.Print(html)
		}
	}
	if err != nil {
		panic(err)
	}
	return
}
`
